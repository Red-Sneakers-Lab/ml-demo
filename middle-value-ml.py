# -*- coding: utf-8 -*-
"""Untitled

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G_3mxA5hBAS1foZ-EkeTEZ_6rnm2gpq5
"""

import numpy as np

# Сигмоида https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BC%D0%BE%D0%B8%D0%B4%D0%B0
def nonlin(x,deriv=False):
    if(deriv==True):
        return nonlin(x)*(1-nonlin(x))
    return 1/(1+np.exp(-x))
    
# набор входных данных (массив это набор из 4х чисел среднее арифметическое которых мы ищем)
# вместе они образубт матрицу которую легко умножать на коефициенты (должны быть 0.5 для каждого числа) что б получить матрицу ответов
data = np.array([  
                [5, 6, 4, 5],
                [0, 7, 1, 2],
                [1, 0, 1, 9],
                [1, 1, 1, 1],
                [3, 5, 6, 7],
                [9, 0, 4, 5]
                ])
    
# выходные данные
# матрица ответов (.T - Транспонирование)
result = np.array([[10, 5, 5.5, 2, 10.5, 9]]).T

# сделаем случайные числа более определёнными
np.random.seed(1)

# инициализируем веса случайным образом
# матрица 4 * 1 с значениями [0, 1)
factor = np.random.random((4, 1))

for iter in range(10000):
    # умножаем матрицу на коефициенты
    iteration_result = np.dot(data, factor)

    # насколько мы ошиблись
    iteration_error = result - iteration_result
  
    # сглаживаем результат и умножаем на ошибку
    iteration_delta = iteration_error * nonlin(iteration_result, True)

    # обновим веса
    factor += np.dot(data.T, iteration_delta) # !!!

print("Коефициенты после тренировки:")
print(factor)

